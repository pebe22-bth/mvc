{% extends "base.html.twig" %}

{% block title %}Metrics{% endblock %}

{% block main %}

<div class="metric">
<h1>Metrics</h1>
<p> </p>    

{% apply markdown_to_html %}
## Introduktion

Den hör sidan innehåller analys av kodkvalitets-metrics och hur man kan jobba med “Clean code”. 

Vi gör analysen med hjälp av "de sex C:na":
- **Codestyle**, vilket handlar om att hålla sig till standarder gällande kodstil. Här får vi hjälp av de linters som finns sedan tidigare,
 framförallt för PHP.
Jag kör PHP CS Fixer som automatiskt rättar enkla fel såsom indent, white spaces and phpmd och phpstan som hjälper till att hitta mer 
komplexa problem som kan orsaka problem, t.ex oanvända variabler, klassimporter som saknas, klasser som inte är tillräckligt hårt typade. 

----

- **Coverage**, som mäter hur stor del av koden som har testats. Ett högre värde är bättre och har man 100% code coverage så är det bra - 
dock kanske inte tidseffektivt att definiera alla specialfall. Data från enhetstesterna som körs med junit (kmom04) inkluderas i 
scrutinizers UI. 

----

- **Complexity**, som avser hur komplex koden är. Önskvärt är att inte ha onödigt komplex kod och om den är det blir den svår att förstå 
och förvalta. ett mätetal som mäter komplexitet är cyclomatic complexity som anger antalet olika väger exekveringen kan ta genom koden.
Många IF/ELSE satser ökar kompplexiteten.
Exempel fråm pmpmetrics rapport nedan där min klass Game21 har en cycklomatic complexitet på 11.

![Complexity]({{ asset('images/metrics/complexity.png') }})


----

- **Cohesion**, vilket mäter hur mycket olika saker en klass gör. helst vill man att en klass är fokuserad på en sak så det 
blir tydligt och mer användningsbart. Det kommer att resultera i fler klasser (som alla utför färre saker).
LCOM (Lack of Cohesion of Methods) är ett mätetal som anger hur mycket metoder i en klass är relaterade till varandra. Värdet 1 är optimalt
medan ett högre värde tyder på att klassen gör olika saker och borde förmodligen brytas isär till fler klasser.
I mitt fall borde jag se över klassen BookRepository för att se om den borde delas 
upp i flera klasser.
![Cohesion]({{ asset('images/metrics/cohesion.png') }})

----

- **Coupling** beskriver i vilken grad klasser är beroende av varandra. Låg koppling är bra och innebär att klasser är mer självständiga och
mer generella. Man brukar prata om "loosly coupled" som en bra princip att använda vid mjukvarudesign. 
Ett mätetal som anger koppling är Afferent Coupling (Ca) som anger hur många andra klasser som är beroende av en viss klass. 
Ett lågt värde är bra och tyder på att klassen är mer självständig.
Exempel nedan från phpmetrics rapport där min klass DeckOfCards har ett Ca värde på 3 vilket betyder att 3 klasser har beroende till den.

![Coupling]({{ asset('images/metrics/coupling.png') }})

----

- **CRAP** står för "Change Risk Analyzer and Predictor" och indikerar hur mycket arbete som krävs för att genomföra kodändringar. Kortfattat anger
ett CRAP värde 1 att det behöver skrivas ett ytterligare testfall för komma upp på banan igen med din kodkvalitet. Vid ett värde på 30 har du nått
gränen för vad som är acceptabelt.

----


## Phpmetrics 
analysera dess rapport för din kod. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod (minst 3 stycken). 
Du vill hitta kod som har förbättringspotential. Visualisera med någon representativ bild från rapporten.

Identifierade problem i koden:

1. Klassen BookRepository har LCOM 3.
se bild ovan "Cohesion".

-----

2. Alla Controller klasser har Instability index = 1, dvs  Ce/(Ce+Ca) = 1 
![Coupling]({{ asset('images/metrics/coupling2.png') }})

----

3. "Class violations" för t.ex BookController som i teorin ska innehålla 0.47 buggar. 
Tips är att se över unit tests för klassen.
![violations]({{ asset('images/metrics/violations.png') }})



## Scrutinizer
Analysera Scrutinizer rapporten för din kod. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod (minst 3 stycken).
Scurinizer rapporten visar följande övergripande information:
![Scrutinizer overview]({{ asset('images/metrics/scrutinizer-before.png') }})
..vilket ju ser ganska bra ut vid en första anblick, förutom att code coverage är låg . 
Detta vista jag om redan och anledningen är att jag inte skrivit test för de tidiga delmomenten i kursen innan vi hade lärt oss jUnit.

Jag vill ändå titta på vilka issues som identifierats och hittar följande:
![Scrutinizer issues]({{ asset('images/metrics/scrutinizer-issues-before.png') }})


### Analys

Här är klickbara Scrutinizer badges för build, coverage och quality.

[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/quality-score.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/?branch=main)

[![Code Coverage](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/coverage.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/?branch=main)

[![Build Status](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/build.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/build-status/main)

[![Code Intelligence Status](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/code-intelligence.svg?b=main)](https://scrutinizer-ci.com/code-intelligence)

Dessa är även placerade i README.md i Github repot.

I bilden ovan listar Scrutinizer de issues den hittat. Sammanfattningsvis är det:
|Typ|Antal|
|-|-|
|Unused code |17|
|Bug |9|
|Best practice |7|
|Comprehencibility |1|

9 av dessa är Major severity, 18 är Minor och 1 uknown.

Exkluderar jag Controller och testklasserna, blir egentligen bara två klasser kvar: 
- CardHand
- Game21

vilka riskerar att innehålla buggar, inte följa best practice och innehåller oanvänd kod.

(.php-cs-fixer.dist.php rapporteras vara ett major problem, men jag ignorerar denna då det är en fil som genererats av csfixer.
BookTest och Game21Test är testklasser som enligt Scrutinizer innehåller oavänd kod. Jag bestämmer mig för att ignorera dessa varningar då
jag tror det är False-Positive)



## Findings

Först tittade jag på **codestyle**. Detta hjälper min IDE till med redan under kodskapandet + csfix, phpstan. Jag ser inte resultat av detta tydligt i phpmetrics,
däremot rapporterar scrutinizer om oanvänd kod, oanvända variabler och typdeklarationer som är fel eller saknas.

Gällande **coverage** så hittar jag data både i phpmetrics och scrutinizer. 
I phpmetrics ser jag tydligt vilka klasser som inte har några tester och även vilka som är mest troliga att vara buggiga då de saknar tester och
har hög komplexitet. Detta ger mig en bra prioritering var jag borde komplettera med tester. phpmetrics pekar på mina controller klasser
i första hand. Scrutiner ger en liknande rapport med coverage i kombination med copemplicity i första hand pekar ut mina controller klasser.

**Complexity** var vi redan inne på då det i kombination med coverage ger en bra bild på var risk för buggar finns. phpmetrics har även en specifik vy
för complexitet som ger detaljerad info om de olika mätvärdena för komplexitet. Här toppar Game21 och BookRepository WMC (Weighted Method Count) 
som är en summering av cyclomatic complexity för alla metoder i klassen. Scrutinizer ger inte en lika tydlig bild, men jag kan ana att den behöver
mer statistik efter fler körningar.

**Cohesion** rapporteras i phpmetrics och tittar jag på LCOM så toppar CardAPIController och BookRepository. 
I Scrutinizer hittar jag inte tydligt rapportering om cohesion.

** Coupling** I phpmetrics toppar mina kontroller klasser Efferrent coupling (Ce), vilke visar att de är beroende av många andra klasser.
De har 0 på Afferebt coupling (Ca) vilket visar att ingen annan klass är beroende av dem.

**CRAP** värdet i scrutinizer ger en hint om hur mycket jobb det är att fixa problem. Högst värden (=mest jobb för att fixa problemen) 
så toppar en del funktioner i mina controller klasser, viklet ger en hint om att det kanske inte är värt mödan att fixa problem där. 
Högsta värdet 30 finns i "CardGameController::draw_multiple()". Vid 30 går brytgränsen om det är värt att lägga tid - det indikerar ändå 
att det skulle vara mödan värt då alla andra värden är lägre.

Jag ser generellt att controller klasserna sticker ut, men givet deras speciella funktio tror jag inte värdena är så representaiva egentligen 
så bestämer mig för att inte lägga möda på att försöka förbättra dem.


## Förbättringar

- BookEntity har tydligt dåligt test coverage vilket behöver fixas.
![BookEntity]({{ asset('images/metrics/coverage-before.png') }})

- Game21 har hög komplexitet och behöver ses över.
![Game21]({{ asset('images/metrics/game21-before.png') }})
- CardGameController har en funktion med CRAP 30 som behöver ses över.
![CardGameController]({{ asset('images/metrics/CRAP-CardGameController.png') }})


Överblick innan förändringar:
![Overview before]({{ asset('images/metrics/PhpMetrics_maintainability_complexity-before.png') }})

Börja med att skriva om förbättringarna, 
vad du tänker göra, varför du väljer dem och hur du tror det kommer påverka mätvärdena för kvalitet.

Implementera sedan förbättringarna.
Analysera därefter rapporterna från phpmetrics och Scrutinizer och notera de nya mätvärdena.
Gör det tydligt hur mätvärdena såg ut innan och efter dina förbättringar.

## Diskussion

där du diskuterar kort kring det du nyss gjort.

Kan man aktivt jobba med kodkvalitet och “clean code” på detta sättet?
Finns det fördelar och kanske nackdelar?
Ser du andra möjligheter att jobba mot “clean code”?
{% endapply %}
</div>

{% endblock %}
