{% extends "base.html.twig" %}

{% block title %}Metrics{% endblock %}

{% block main %}

<div class="metric">
<h1>Metrics</h1>
<p> </p>    

{% apply markdown_to_html %}
## Introduktion

Den hör sidan innehåller analys av kodkvalitets-metrics och hur man kan jobba med “Clean code”. 

Vi gör analysen med hjälp av "de sex C:na":
- **Codestyle**, vilket handlar om att hålla sig till standarder gällande kodstil. Här får vi hjälp av de linters som finns sedan tidigare,
 framförallt för PHP.
Jag kör PHP CS Fixer som automatiskt rättar enkla fel såsom indent, white spaces and phpmd och phpstan som hjälper till att hitta mer 
komplexa problem som kan orsaka problem, t.ex oanvända variabler, klassimporter som saknas, klasser som inte är tillräckligt hårt typade. 

----

- **Coverage**, som mäter hur stor del av koden som har testats. Ett högre värde är bättre och har man 100% code coverage så är det bra - 
dock kanske inte tidseffektivt att definiera alla specialfall. Data från enhetstesterna som körs med junit (kmom04) inkluderas i 
scrutinizers UI. 

----

- **Complexity**, som avser hur komplex koden är. Önskvärt är att inte ha onödigt komplex kod och om den är det blir den svår att förstå 
och förvalta. ett mätetal som mäter komplexitet är cyclomatic complexity som anger antalet olika väger exekveringen kan ta genom koden.
Många IF/ELSE satser ökar kompplexiteten.
Exempel fråm phpmetrics rapport nedan där min klass Game21 har en cyclomatic complexity på 11.

![Complexity]({{ asset('images/metrics/complexity.png') }})


----

- **Cohesion**, vilket mäter hur mycket olika saker en klass gör. helst vill man att en klass är fokuserad på en sak så det 
blir tydligt och mer användningsbart. Det kommer att resultera i fler klasser (som alla utför färre saker).
LCOM (Lack of Cohesion of Methods) är ett mätetal som anger hur mycket metoder i en klass är relaterade till varandra. Värdet 1 är optimalt
medan ett högre värde tyder på att klassen gör olika saker och borde förmodligen brytas isär till fler klasser.
I mitt fall borde jag se över klassen BookRepository för att se om den borde delas 
upp i flera klasser.
![Cohesion]({{ asset('images/metrics/cohesion.png') }})

----

- **Coupling** beskriver i vilken grad klasser är beroende av varandra. Låg koppling är bra och innebär att klasser är mer självständiga och
mer generella. Man brukar prata om "loosly coupled" som en bra princip att använda vid mjukvarudesign. 
Ett mätetal som anger koppling är Afferent Coupling (Ca) som anger hur många andra klasser som är beroende av en viss klass. 
Ett lågt värde är bra och tyder på att klassen är mer självständig.
Exempel nedan från phpmetrics rapport där min klass DeckOfCards har ett Ca värde på 3 vilket betyder att 3 klasser har beroende till den.

![Coupling]({{ asset('images/metrics/coupling.png') }})

----

- **CRAP** står för "Change Risk Analyzer and Predictor" och indikerar hur mycket arbete som krävs för att genomföra kodändringar. Kortfattat anger
ett CRAP värde 1 att det behöver skrivas ett ytterligare testfall för komma upp på banan igen med din kodkvalitet. Vid ett värde på 30 har du nått
gränen för vad som är acceptabelt.

----


## Phpmetrics 
analysera dess rapport för din kod. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod (minst 3 stycken). 
Du vill hitta kod som har förbättringspotential. Visualisera med någon representativ bild från rapporten.

Identifierade problem i koden:

1. Klassen BookRepository har LCOM 3.
se bild ovan "Cohesion".

-----

2. Alla Controller klasser har Instability index = 1, dvs  Ce/(Ce+Ca) = 1 
![Coupling]({{ asset('images/metrics/coupling2.png') }})

----

3. "Class violations" för t.ex BookController som i teorin ska innehålla 0.47 buggar. 
Tips är att se över unit tests för klassen.
![violations]({{ asset('images/metrics/violations.png') }})



## Scrutinizer
Analysera Scrutinizer rapporten för din kod. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod (minst 3 stycken).
Scurinizer rapporten visar följande övergripande information:
![Scrutinizer overview]({{ asset('images/metrics/scrutinizer-before.png') }})
..vilket ju ser ganska bra ut vid en första anblick, förutom att code coverage är låg . 
Detta vista jag om redan och anledningen är att jag inte skrivit test för de tidiga delmomenten i kursen innan vi hade lärt oss jUnit.

Jag vill ändå titta på vilka issues som identifierats och hittar följande:
![Scrutinizer issues]({{ asset('images/metrics/scrutinizer-issues-before.png') }})


### Analys

Här är klickbara Scrutinizer badges för build, coverage och quality.

[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/quality-score.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/?branch=main)

[![Code Coverage](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/coverage.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/?branch=main)

[![Build Status](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/build.png?b=main)](https://scrutinizer-ci.com/g/pebe22-bth/mvc/build-status/main)

[![Code Intelligence Status](https://scrutinizer-ci.com/g/pebe22-bth/mvc/badges/code-intelligence.svg?b=main)](https://scrutinizer-ci.com/code-intelligence)

Dessa är även placerade i README.md i Github repot.

I bilden ovan listar Scrutinizer de issues den hittat. Sammanfattningsvis är det:
|Typ|Antal|
|-|-|
|Unused code |17|
|Bug |9|
|Best practice |7|
|Comprehencibility |1|

9 av dessa är Major severity, 18 är Minor och 1 uknown.

Exkluderar jag Controller och testklasserna, blir egentligen bara två klasser kvar: 
- CardHand
- Game21

vilka riskerar att innehålla buggar, inte följa best practice och innehåller oanvänd kod.

(.php-cs-fixer.dist.php rapporteras vara ett major problem, men jag ignorerar denna då det är en fil som genererats av csfixer.
BookTest och Game21Test är testklasser som enligt Scrutinizer innehåller oavänd kod. Jag bestämmer mig för att ignorera dessa varningar då
jag tror det är False-Positive)



## Findings

Först tittade jag på **codestyle**. Detta hjälper min IDE till med redan under kodskapandet + csfix, phpstan. Jag ser inte resultat av detta tydligt i phpmetrics,
däremot rapporterar scrutinizer om oanvänd kod, oanvända variabler och typdeklarationer som är fel eller saknas.

Gällande **coverage** så hittar jag data både i phpmetrics och scrutinizer. 
I phpmetrics ser jag tydligt vilka klasser som inte har några tester och även vilka som är mest troliga att vara buggiga då de saknar tester och
har hög komplexitet. Detta ger mig en bra prioritering var jag borde komplettera med tester. phpmetrics pekar på mina controller klasser
i första hand. Scrutiner ger en liknande rapport med coverage i kombination med copemplicity i första hand pekar ut mina controller klasser.

**Complexity** var vi redan inne på då det i kombination med coverage ger en bra bild på var risk för buggar finns. phpmetrics har även en specifik vy
för complexitet som ger detaljerad info om de olika mätvärdena för komplexitet. Här toppar Game21 och BookRepository WMC (Weighted Method Count) 
som är en summering av cyclomatic complexity för alla metoder i klassen. Scrutinizer ger inte en lika tydlig bild, men jag kan ana att den behöver
mer statistik efter fler körningar.

**Cohesion** rapporteras i phpmetrics och tittar jag på LCOM så toppar CardAPIController och BookRepository. 
I Scrutinizer hittar jag inte tydligt rapportering om cohesion.

** Coupling** I phpmetrics toppar mina kontroller klasser Efferrent coupling (Ce), vilke visar att de är beroende av många andra klasser.
De har 0 på Afferebt coupling (Ca) vilket visar att ingen annan klass är beroende av dem.

**CRAP** värdet i scrutinizer ger en hint om hur mycket jobb det är att fixa problem. Högst värden (=mest jobb för att fixa problemen) 
så toppar en del funktioner i mina controller klasser, viklet ger en hint om att det kanske inte är värt mödan att fixa problem där. 
Högsta värdet 30 finns i "CardGameController::draw_multiple()". Vid 30 går brytgränsen om det är värt att lägga tid - det indikerar ändå 
att det skulle vara mödan värt då alla andra värden är lägre.

Jag ser generellt att controller klasserna sticker ut, men givet deras speciella funktio tror jag inte värdena är så representaiva egentligen 
så bestämer mig för att inte lägga möda på att försöka förbättra dem.


## Förbättringar

- BookEntity har tydligt dåligt test coverage vilket behöver fixas. Resultatet borde bli ökad code coverage.
![BookEntity]({{ asset('images/metrics/coverage-before.png') }})

- Game21 har hög cyclomatic complexity och behöver ses över.
![Game21]({{ asset('images/metrics/game21-before.png') }})

- CardHand har enligt Scrutinizer buggar med major severity som behöver fixas.
![CardHand]({{ asset('images/metrics/CardHand-before.png') }})

### Resultat efter förändringar
- BookEntity code coverage är nu 100% efter att tests lagts till.
![BookEntity]({{ asset('images/metrics/coverage-after.png') }})

- Game21. 
Trots att jag lagt till "early returns" i alla IF satser, brutit ut IF satserna i helper functions 
(har spelaren blivit tjock, 
har banken dragit till 17, är spearens värde högre än bankens, osv) samt tagit bort ett par IF satser som var onödiga
har jag inte lyckats sänka cyclomatic complexity. Den är fortfarande 11. Dessutom har den totala komplixitetenm ökat:
WMC har ökat från 15 till 17 - antagligen för att antal funktioner i klassen har ökat.
Jag bestämmer mig ändå för att behålla ändringarna: Koden är renare och lättare att förstå.

![Game21]({{ asset('images/metrics/game21-after.png') }})


- CardHand bug fix. Den här klassen innehåll 3 major issues innan förändringen, vilket nu fixats till. Man
kan se att totala antal issues minskat från 24 till 21.
![CardHand]({{ asset('images/metrics/CardHand-after.png') }})

## Diskussion

Bra övning för att se vilken analys man enkelt kan få på "köpet". Väldigt enkelt att använda Scrutinizer när den 
körs automatiskt vid commit av kod, dessutom bra med grafik för att snabbt se proportioner på felen.
Analysen gör mer nytta med större kodbas. Jag försökte få ned komplexitetem på mitt 21-spel, men det gick inte bra av
den enkla anledningen att det nog inte gick att förenkla så mycket - spelets logik behöver implementeras på någåt sätt
och det finns en gräns hur förenklad den logiken kan vara.
Jag hittade några fel som var rena buggar - iofs i phpdoc men ändå, det var fel som upptäcktes.

Som professionell utvecklare borde man absolut jobba med den här typen av verktyg för att höja kvaliteten, dock ska man
inte förlita sig för mycket då det ändå är "statisk" analys och det kan finnas andra ställen att investera sin tid som
löser problem som inte hittas här. Nackdelen som sagt innan att man ägnar för mycket tid åt för små problem, som i fallet 
med min Game21 klass ovan. Jag gillar CRAP värdet som faktiskt tar hänsyn till hur mycket det kostar att åtgärda potentiella 
problem.

Andra sätt att jobba mot clean code är parprogrammering, pull requests förfaranden och andra typer av samarbeten och granskning 
av kod så man lär av varandra. 


{% endapply %}
</div>

{% endblock %}
