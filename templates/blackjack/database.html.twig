{% extends "bjbase.html.twig" %}

{% block title %}Database{% endblock %}

{% block main %}

{% include 'blackjack/nav.html.twig' %}
{%include('card/flash.html.twig') %}


    <h1>Databasen</h1>
    <p> 
        

    </p>
    {% apply markdown_to_html %}
    ## ER
    
    ![Flödesdiagram]({{ asset('images/blackjack/database.png') }})
    ### Player-tabellen
    Här sparas ett unikt id, namn och antal pengar som spelaren för tillfället har.
    ### Highscore-tabellen
    Här sparas det högsta antal pengar respektive spelare har haft med en referens (player_id) till spelarens id i player-tabellen.

    ## Relationer 
    Highscore tabellens 'player_id' är en foreign key till player tabellens 'id'.

    ## Databashanterare
    SQLite används.

    ## Enhetstester
    Enhetstester körs på tabellernas ORM Entities, fick dock inte till fungerande tester på funktionerna som 
    finns definierade i ORM Repository.

    ## Enhetstester på scrutinizer med databasen
    Scrutinizer verkar inte fånga uppkorrekt att enhetstester körts med ORM ramverket: 
    Test coverage markeras med ett frågetecken.

    ## Erfarenheter av ORM respektive "direkt access" till databasen.
    Tanken med ORM är god och det fungerar bra, dock är det en startsträcka att lära sig var och hur 
    funktioner i klasserna ska skrivas och Entities och Repositories förhåller sig till koden.
    I databaskursen var vi tvungna att komponera sql, conatraints, foreign keys, etc själv, medan man
    med ORM får en del gratis. man får desutom hjälp med funktioner i php istället för att skriva avancerad 
    SQL, vilket kan vara bra för de som inte är så bevandrade i SQL. Förodliugen är det lättare att strukturera sina 
    klasser med ORM och med det få ökad möjlighet till användbarhet, men det  skulle jag behöver mer erfarenhet 
    för att förstå bättre så blir spekulation.
    Genom att ORM har koll på RDBMS-specifik SQL så slipper man vara expert på vad som fungerar i olika miljöer.
    Detta är dock inget man kan nyttja on-the-fly vilket är synd. När jag bytte från MariaDB till SQLite3 behövde jag 
    generera om mina "migreringar" - det hade ju varit sjysst om ORM hade stöd för att migrera från en 
    databashanterare till en annan med hjälp av att generera en migreringsfil för det.
    Förmodligen begränsar ORM om man vill nyttja avancerat SQL.

    
    {% endapply %}



{% endblock %}